# 附录A.与Pygame集成

本附录显示了如何在OpenCV应用程序中设置Pygame库以及如何使用Pygame进行窗口管理。 此外，附录还概述了Pygame的其他功能以及一些学习Pygame的资源。

![Note](img/00001.jpg)

### 注意

本章的所有完成代码都可以从我的网站下载：[http://nummist.com/opencv/3923_06.zip](http://nummist.com/opencv/3923_06.zip)。

![Note](img/00001.jpg)

# 安装Pygame

假设我们已经根据第1章，“设置OpenCV”中描述的方法之一设置了Python。 根据我们现有的设置，我们可以通过以下方式之一安装Pygame：

*   带有32位Python的Windows：从[以下位置](http://pygame.org/ftp/pygame-1.9.1.win32-py2.7.msi)下载并安装Pygame 1.9.1。
*   带有64位Python的Windows：从[以下位置](http://www.lfd.uci.edu/~gohlke/pythonlibs/2k2kdosm/pygame-1.9.2pre.win-amd64-py2.7.exe)下载并安装Pygame 1.9.2预览版。
*   带有Macports的Mac：打开“终端”并运行以下命令：

    ```py

    $ sudo port install py27-game

    ```

*   带有Homebrew的Mac：打开Terminal并运行以下命令来安装Pygame的依赖项，然后安装Pygame本身

    ```py

    $ brew install sdl sdl_image sdl_mixer sdl_ttf smpeg portmidi
    $ /usr/local/share/python/pip install \
    > hg+http://bitbucket.org/pygame/pygame

    ```

*   Ubuntu及其衍生版本：打开“终端”并运行以下命令：

    ```py

    $ sudo apt-get install python-pygame

    ```

*   其他类似Unix的系统：Pygame在许多系统的标准存储库中可用。 典型的软件包名称包括`pygame`, `pygame27`, `py-game`, `py27-game`, `python-pygame,`和`python27-pygame`.。

现在，Pygame应该可以使用了。

# 文档和教程

Pygame的API文档和一些教程可以在[以下网址](http://www.pygame.org/docs/)在线找到。

Al Sweigart的《使用Python和Pygame制作游戏》是一本烹饪手册，用于在Pygame 1.9.1 \中重新创建几个经典游戏。 免费的电子版本可从[以下网站](http://inventwithpython.com/pygame/chapters/)在线获得。或在[以下网站](http://inventwithpython.com/makinggames.pdf)下载PDF文件。

# 派生`Manager.WindowManager`

如第2章，“处理照相机，文件和GUI”中所述，我们的面向对象设计使我们可以轻松地交换OpenCV的HighGUI窗口管理器 另一个窗口管理器，例如Pygame。 为此，我们只需要继承我们的`managers.WindowManager`类的子类，并覆盖四个方法：`createWindow()`，`show()`，`destroyWindow()`和`processEvents()`。 另外，我们需要导入一些新的依赖项。

要继续，我们需要第2章“处理照相机，文件和GUI”中的`managers.py`文件，和第4章“用Haar级联跟踪人脸”中的`utils.py`文件。 在`utils.py`中，我们只需要一个函数`isGray()`，我们在第4章，“用Haar级联跟踪人脸”中实现。 让我们编辑`managers.py`以添加以下导入：

```py
import pygame
import utils
```

同样在`managers.py`中，在执行`WindowManager`之后的某个位置，我们想添加名为`PygameWindowManager`的新子类：

```py
class PygameWindowManager(WindowManager):
    def createWindow(self):
        pygame.display.init()
        pygame.display.set_caption(self._windowName)
        self._isWindowCreated = True
    def show(self, frame):
        # Find the frame's dimensions in (w, h) format.
        frameSize = frame.shape[1::-1]
        # Convert the frame to RGB, which Pygame requires.
        if utils.isGray(frame):
            conversionType = cv2.COLOR_GRAY2RGB
        else:
            conversionType = cv2.COLOR_BGR2RGB
        rgbFrame = cv2.cvtColor(frame, conversionType)
        # Convert the frame to Pygame's Surface type.
        pygameFrame = pygame.image.frombuffer(
            rgbFrame.tostring(), frameSize, 'RGB')
        # Resize the window to match the frame.
        displaySurface = pygame.display.set_mode(frameSize)
        # Blit and display the frame.
        displaySurface.blit(pygameFrame, (0, 0))
        pygame.display.flip()
    def destroyWindow(self):
        pygame.display.quit()
        self._isWindowCreated = False
    def processEvents(self):
        for event in pygame.event.get():
            if event.type == pygame.KEYDOWN and \
                    self.keypressCallback is not None:
                self.keypressCallback(event.key)
            elif event.type == pygame.QUIT:
                self.destroyWindow()
                return
```

注意，我们使用了两个Pygame模块：`pygame.display`和`pygame.event`。

A window is created by calling `pygame.display.init()` and destroyed by calling `pygame.display.quit()`. Repeated calls to `display.init()` have no effect, as Pygame is intended for single-window applications only. The Pygame window has a drawing surface of type `pygame.Surface`. To get a reference to this `Surface`, we can call `pygame.display.get_surface()` or `pygame.display.set_mode()`. The latter function modifies the `Surface` entity's properties before returning it. A `Surface` entity has a `blit()` method, which takes, as arguments, another `Surface` and a coordinate pair where the latter `Surface` should be "blitted" (drawn) onto the first. When we are done updating the window's `Surface` for the current frame, we should display it by calling `pygame.display.flip()`.

Events, such as `keypresses`, are polled by calling `pygame.event.get()`, which returns the list of all events that have occurred since the last call. Each event is of type `pygame.event.Event` and has the property `type`, which indicates the category of an event such as `pygame.KEYDOWN` for keypresses and `pygame.QUIT` for the window's **Close** button being clicked. Depending on the value of `type`, an `Event` entity may have other properties, such as `key` (an ASCII key code) for the `KEYDOWN` events.

Relative to the base `WindowManager` that uses HighGUI, `PygameWindowManager` incurs some overhead cost by converting between OpenCV's image format and Pygame's `Surface` format of each frame. However, `PygameWindowManager` offers normal window closing behavior, whereas the base `WindowManager` does not.

# Modifying the application

Let's modify the `cameo.py` file to use `PygameWindowManager` instead of `WindowManager`. Find the following line in `cameo.py`:

```py
from managers import WindowManager, CaptureManager
```

Replace it with:

```py
from managers import PygameWindowManager as WindowManager, \
                     CaptureManager
```

That's all! Now `cameo.py` uses a Pygame window that should close when the standard **Close** button is clicked.

# Further uses of Pygame

We have used only some basic functions of the `pygame.display` and `pygame.event` modules. Pygame provides much more functionality, including:

*   Drawing 2D geometry
*   Drawing text
*   Managing groups of drawable AI entities (sprites)
*   Capturing various input events relating to the window, keyboard, mouse, and joysticks/gamepads
*   Creating custom events
*   Playback and synthesis of sounds and music

For example, Pygame might be a suitable backend for a game that uses computer vision, whereas HighGUI would not be.

# Summary

By now, we should have an application that uses OpenCV for capturing (and possibly manipulating) images, while using Pygame for displaying the images and catching events. Starting from this basic integration example, you might want to expand `PygameWindowManager` to wrap additional Pygame functionality or you might want to create another `WindowManager` subclass to wrap another library.